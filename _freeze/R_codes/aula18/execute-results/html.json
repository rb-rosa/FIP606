{
  "hash": "fbea1d94e781689c50a5691e55e776eb",
  "result": {
    "markdown": "---\ntitle: \"**Transformação Box Cox**\"\nformat: html\neditor: visual\n\nexecute: \n  freeze: auto\n  cache: true\n  warning: false\n---\n\n\nAula 18\n\nObservação: dados da aula 10\n\n## Transformação de dados\n\n-   O modelo de Análise de Variância pressupõe que exista homocedasticidade, ou seja, que os tratamentos apresentem a mesma variabilidade;\n\n-   Algumas vezes este pressuposto pode não ser atendido e assim, para corrigir este problema existe uma saída por vezes bastante simples que é a transformação de dados;\n\n-   Esta técnica consiste na utilização de um artifício matemático para tornar o modelo de ANOVA válido.\n\n## Transformação Box-Cox\n\nOs estatísticos George Box e David Cox desenvolveram um procedimento para identificar um expoente apropriado (Lambda = 1) a ser usado para transformar dados em uma \"forma normal\". Quando o valor de Lambda é 1, nenhuma transformação é necessária, produz resultados idênticos aos originais. O valor Lambda indica a potência à qual todos os dados devem ser elevados. Para isso, a transformação de potência Box-Cox busca de Lambda = -5 a Lamba = +5 até encontrar o melhor valor. A tabela abaixo mostra algumas transformações Box-Cox comuns, onde *Y'* é a transformação dos dados oriinais *Y*.Observe que para Lambda = 0, a transformação NÃO é *Y 0* (porque seria 1 para cada valor), mas sim o logaRitmo de *Y*.\n\n|      |                       |\n|------|-----------------------|\n| 1    | Y'                    |\n| -2   | Y^-2^ = 1/Y^2^        |\n| -1   | Y^-1^ = 1/Y^1^        |\n| -0.5 | Y^-0.5^ = 1/(Sqrt(Y)) |\n| 0    | log(Y)                |\n| 0.5  | Y^0.5^ = Sqrt(Y)      |\n| 1    | Y^1^ = Y              |\n| 2    | Y^2^                  |\n\nA função `boxcox` foi implementada no pacote `MASS`. O lambda (λ) é utilizado para transformar a variável resposta pela fórmula \"variávelresposta \\^ lambda - 1\".\n\n## Transformando dados\n\n\n::: {.cell hash='aula18_cache/html/unnamed-chunk-1_b420ae1dda90bd4cb3aeb7ab59ed9c74'}\n\n```{.r .cell-code}\nlibrary(readxl)\nlibrary(tidyverse)\nmicelial <- read_excel(\"dados-diversos.xlsx\", \"fungicida_vaso\")\nmicelial <- micelial |> \n  mutate(inc = inf_seeds/n_seeds*100,\n         rank_inc = rank(inc))\n\n# rank transforma dados quando tem-se dois fatores. rank transforma a variável resposta para dois fatores\nrank_anova <- aov(rank_inc ~ treat*dose, data = micelial)\nsummary(rank_anova)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Df Sum Sq Mean Sq F value  Pr(>F)   \ntreat        1 220.00  220.00  14.204 0.00168 **\ndose         1 105.34  105.34   6.801 0.01904 * \ntreat:dose   1  80.34   80.34   5.187 0.03684 * \nResiduals   16 247.82   15.49                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\nlibrary(emmeans)\nmeans_rank <- emmeans(rank_anova, ~ treat | dose)\nlibrary(multcomp)\nlibrary(multcompView)\ncld(means_rank)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndose = 0.5:\n treat        emmean   SE df lower.CL upper.CL .group\n Tebuconazole   6.90 1.76 16     3.17     10.6  1    \n Ionic liquid  18.00 1.76 16    14.27     21.7   2   \n\ndose = 2.0:\n treat        emmean   SE df lower.CL upper.CL .group\n Tebuconazole   6.75 1.97 16     2.58     10.9  1    \n Ionic liquid   9.75 1.61 16     6.34     13.2  1    \n\nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n:::\n\n```{.r .cell-code}\n# usar boxcox\nlibrary(MASS)\n\n# criando o objeto insects\ninsects <- tibble::as_tibble(InsectSprays)|> \n  dplyr::select(spray, count)\ninsects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 72 × 2\n   spray count\n   <fct> <dbl>\n 1 A        10\n 2 A         7\n 3 A        20\n 4 A        14\n 5 A        14\n 6 A        12\n 7 A        10\n 8 A        23\n 9 A        17\n10 A        20\n# ℹ 62 more rows\n```\n:::\n\n```{.r .cell-code}\nb <- boxcox(lm(insects$count+0.1 ~ 1)) # o valor 0.1 é pq tinha zero nos dados; insects$count é a variável resposta \n```\n\n::: {.cell-output-display}\n![](aula18_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Encontra o lambda\nlambda <- b$x[which.max(b$y)]\nlambda\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4242424\n```\n:::\n\n```{.r .cell-code}\n# Após achar o lambda, a variável resposta é transformada com a fórmula abaixo\n\ninsects$count2 <- (insects$count ^ lambda - 1) / lambda # insects$count2 cria count2 automaticamente, o lambda transformado\ninsects$count2 # variável resposta transformada\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3.903635  3.024469  6.043993  4.864268  4.864268  4.407118  3.903635\n [8]  6.557185  5.484274  6.043993  4.864268  4.640760  4.161975  5.484274\n[15]  6.219699  4.161975  5.285168  4.864268  5.484274  5.484274  5.863153\n[22]  6.219699  3.024469  4.640760 -2.357143  0.000000  3.024469  0.805831\n[29]  1.399509  0.000000  0.805831  0.000000  1.399509 -2.357143  0.000000\n[36]  1.887150  1.399509  2.308577  4.407118  2.683787  1.887150  1.399509\n[43]  2.308577  2.308577  2.308577  2.308577  0.805831  1.887150  1.399509\n[50]  2.308577  1.399509  2.308577  1.399509  2.683787  0.000000  0.000000\n[57]  1.399509  0.805831  2.683787  1.887150  4.161975  3.629951  5.078760\n[64]  6.390651  5.078760  5.285168  4.640760  3.903635  7.033117  7.033117\n[71]  6.719601  4.640760\n```\n:::\n\n```{.r .cell-code}\nhist(insects$count) # muito assimétrico\n```\n\n::: {.cell-output-display}\n![](aula18_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(insects$count2) # mais simétrico\n```\n\n::: {.cell-output-display}\n![](aula18_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n```{.r .cell-code}\ninsects$count2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3.903635  3.024469  6.043993  4.864268  4.864268  4.407118  3.903635\n [8]  6.557185  5.484274  6.043993  4.864268  4.640760  4.161975  5.484274\n[15]  6.219699  4.161975  5.285168  4.864268  5.484274  5.484274  5.863153\n[22]  6.219699  3.024469  4.640760 -2.357143  0.000000  3.024469  0.805831\n[29]  1.399509  0.000000  0.805831  0.000000  1.399509 -2.357143  0.000000\n[36]  1.887150  1.399509  2.308577  4.407118  2.683787  1.887150  1.399509\n[43]  2.308577  2.308577  2.308577  2.308577  0.805831  1.887150  1.399509\n[50]  2.308577  1.399509  2.308577  1.399509  2.683787  0.000000  0.000000\n[57]  1.399509  0.805831  2.683787  1.887150  4.161975  3.629951  5.078760\n[64]  6.390651  5.078760  5.285168  4.640760  3.903635  7.033117  7.033117\n[71]  6.719601  4.640760\n```\n:::\n:::\n\n\nO lambda tranformado é usado na ANOVA\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}